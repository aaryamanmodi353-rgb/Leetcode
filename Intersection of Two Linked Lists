public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

     HashMap<ListNode, Integer> hmap =new  HashMap<>();

     ListNode curr = headA;

     while(curr != null){

        hmap.put(curr, hmap.getOrDefault(curr,0)+1);
        curr = curr.next;

        
     }

     curr = headB;

     while(curr != null){
        if(hmap.containsKey(curr)){
            return curr;
            
        }
        hmap.put(curr,hmap.getOrDefault(curr,0)+1);
        curr = curr.next;

     }
        return null;
    }
}


/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {


    public static ListNode intersectionPoint(ListNode smaller,ListNode greater, int difference){
        while(difference != 0){
            greater = greater.next;
            difference--;
        }

        while(greater != null && smaller != null){
            if(greater == smaller){
                return greater;
            }
            greater = greater.next;
            smaller = smaller.next;

        }
        return null;
        
    }
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curr = headA;
        int countA = 0;
        int countB = 0;
        ListNode answer = null;


        while(curr != null){
            curr = curr.next;
            countA++;

        }

        curr = headB;

        while(curr != null){
            curr = curr.next;
            countB++;
        }

       if(countA > countB){
        answer = intersectionPoint(headB, headA, countA - countB);

    
       }
       else{
        answer = intersectionPoint(headA, headB, countB - countA);

        
       }
       return answer;

        

        
    }
}
