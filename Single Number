class Solution {
    public int singleNumber(int[] nums) {

        int i = 0;
        int result = 0;
        for(i = 0;i < nums.length;i++){
            result = result^ nums[i];

            
        }
        return result;
    }
}
//we can either use hashmap or xor operator

//Medium
class Solution {
    public int singleNumber(int[] nums) {

        int i = 0;
       
        int ans = 0;

        for(i = 0; i < 32;i++){
             int count = 0;
            for(int j = 0; j < nums.length;j++){
                if((nums[j] &(1 << i)) != 0){
                    count++;
       }
  }
     
          if(count % 3 == 1){
            ans = ans | (1 << i);

             }
        }

        return ans;
        
    }
}


//so here the approach we are using is to just check for every bit if there exist a set bit we can increase the count
//the new count value will be divided by 3 to check if there is any unique bit of number that has come along with it
//if yes we will set the answer
//the loop continues



//Sorting
class Solution {
    public int singleNumber(int[] nums) {


        Arrays.sort(nums);

        int i = 0;
        for(i = 1;i < nums.length;i += 3){

            if(nums[i] != nums[i-1]){
                return nums[i-1];
            }

        }
        return nums[nums.length-1];


       
        
    }
}

//just sorting it and matching the current num and last num if it matches simply return it
//the last element is returned if no element is found in between or at the start


//Box
class Solution {
    public int singleNumber(int[] nums) {

        int i = 0;
        int findNum = 0;
        int varNum = 0;
        for(i = 0;i < nums.length;i++){

            findNum = findNum ^ nums[i] & ~varNum;
            varNum = varNum ^ nums[i] & ~findNum;
        
        }

        return findNum;

       
        
    }
}


//take two variables and if the number is not stored in second one then the number is stored in the previous one
//if the number come again then it is deleted from the previous one and stored in the second one
//if the number appears thrice then it is tried with the previous one and due the second variable storing the number it could not be stored in previous one
//delete the number from the second one
//so the box is empty now
//this process continues till it found the required number


//If there are two single number in the array
class Solution {
    public int[] singleNumber(int[] nums) {



        int resultaddone = 0;
        int resultaddtwo = 0;

        int i = 0;

        long bitCal = 0;
        for(i = 0;i < nums.length;i++){
            bitCal= bitCal ^ nums[i];
            

        }
        bitCal = (bitCal & (bitCal-1))  ^ bitCal;



        for(i = 0; i < nums.length;i++){
            if((bitCal & nums[i]) != 0){
                resultaddone = resultaddone ^ nums[i];
            }

            if((bitCal & nums[i]) == 0){
                resultaddtwo = resultaddtwo ^ nums[i];

            }


        }


        int resultarr[] = {resultaddone,resultaddtwo};


        return resultarr;
        
        
    }
}

//first approach is of using Hashmaps but it will consume more time and more space 
//use the second apporach of (long since 2^31-1)xor by creating two variables so firsly do the xor of every number in the array to get the final number
//the number is then used to identify the first bit in the right side so for that just follow the xor operator way 
//then two variables which were created earlier so if the bit used for identifying and the number with and operator gives zero keep it seperatly in another variable
//the one which does not give zero keep it in a separate varaible
//so then finally create an array of these two variables





